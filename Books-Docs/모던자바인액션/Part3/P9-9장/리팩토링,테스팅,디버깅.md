## 리팩토링, 테스팅, 디버깅
- 람다 표현식으로 코드 리팩토링 하기
- 람다 표현식이 객체지향 설계 패턴에 미치는 영향
- 람다 표현식 테스팅
- 람다 표현식과 스트림 API 사용 코드 디버깅

새 프로젝트는 모든 것을 처음부터 시작하는 것이 아닌, 많은 새 프로젝트는 예전 자바로 구현된 기존 코드를 기반으로 시작한다 <br>
람다 표현식, 스트림을 이용해 가독성과 유연성을 높이려면 기존 코드를 어떻게 리팩토링 해야하는지에 대해서 설명해볼 것이다. <br>
그리고 람다 표현식을 이용해, 전략, 템플릿 메소드, 옵저버, 의무 체인, 팩토리 등 객체지향 디자인 패턴을 어떻게 간소화 할 수 있는지도 살펴보자 <br>
그리고 마지막에는 람다 표현식과 스트림 API 를 사용하는 코드를 테스트하고 디버깅 하는 방법을 설명한다 

### 가독성과 유연성을 개선하는 리팩토링 
람다 표현식은 익명 클래스보다 코드를 좀 더 간결하게 만든다.<br>
메소드가 있을 때는 메소드 참조를 이용해서 람다보다 더 간결한 코드를 구현할 수도 있다 <br>
그 뿐만 아니라 람다 표현식은 동작 파라미터화의 형식을 지원하므로 람다 표현식을 이용한 코드는 더 큰 유연성을 갖출 수 있다. <br>
즉 람다 표현식을 이용한 코드는 다양한 요구사항 변화에 대응할 수 있도록 동작을 파라미터화 한다.<br>

#### 코드 가독성 개선
코드 가독성을 개선한다는 것은 우리가 구현한 코드를 다른 사람이 쉽게 이해하고 유지보수 할 수 있게 만드는 것을 의미한다 <br>
아래서 리팩토링 예제를 보며 이해를 도울 예정이다.
- 익명 클래스를 람다 표현식으로 리팩토링 하기
- 람다 표현식을 메소드 참조로 리팩토링하기
- 명령형 데이터 처리를 스트림으로 리팩토링 하기.

#### 익명 클래스를 람다 표현식으로 리팩토링 하기
하나의 추상 메소드르 구현하는 익명 클래스는 람다 표현식으로 리팩토링 할 수 있다.<br>
```java
	Runnable r1 = new Runnable() {
		@Override
		public void run () {
			System.out.println("hello");
		}
	};
	Runnable r2 = () -> System.out.println("hello");
```

위 처럼 람다를 이용해, 익명 클래스를 가독성 있게 바꿀수 있다 <br>
하지만 모든 익명클래스를 람다 표현식으로 변환할 수 있는 것은 아니다.
1) 익명클래스에서 사용한 this 와 super 는 람다 표현식에서 다른 의미를 갖는다. 
- 익명 클래스에서 this 는 익명 클래스 자신을 가리키지만, 람다에서 this 는 람다를 감싸는 클래스를 가리킨다.
2) 익명 클래스는 감싸고 있는 클래스의 변수를 가릴수 있다(shadow variable) 하지만, 람다는 변수를 가릴 수 없다.
```java
	int a = 10;
	Runnable r1 = () -> {
		int a = 2; // 컴파이 ㄹ에러
		System.out.println(a);
	};
	Runnable r2 = () -> {
		int a = 10; // 잘 작동함
		System.out.println(a);
	};
```

3) 익명 클래스를 람다 표현식으로 바꾸면 컨텐스트 오버로딩에 따른 모호함이 초래 될 수 있다.
- 익명클래스는 인스턴스화 할 때 명시적으로 형식이 정해지는 반면 람다의 형식은 컨텐스트에 따라 달라진다. 

#### 람다 표현식을 메소드 참조로 리팩토링 하기
람다 표현식은 쉽게 전달할 수 있는 짧은 코드이다. <br>
하지만 람다 표현식 대신 **메소드 참조**를 이용하면 가독성을 높일 수 있다.
메소드 참조의 메소드명으로 코드의 의도를 명확하게 알릴 수 있기 때문이다. 아래 예제를 비교해보자.
```java

```

































