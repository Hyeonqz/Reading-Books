## 결론 그리고 자바의 미래
- 자바 8의 기능과 자바 8이 프로그래밍 형식에 가져올 변화
- 새로운 자바 9 모듈 시스템
- 6개월 주기의 점진적 자바 릴리스 생명주기
- 첫 번째 점진적 릴리스 자바 10
- 미래 자바 버전에 추가되리라 기대하는 기능

### 자바 8의 기능 리뷰
자바 8에 추가된 대부분의 새로운 기능은 잦바에서 함수형 프로그래밍을 쉽게 적용할 수 있도록 도와준다는 사실을 강조할 것이다 <br>
- 멀티코어 프로세스의 파워를 충분히 활용해야 한다.
  - 개별 CPU 코어의 속도가 빨라지고 있다. 즉 코드를 병렬로 실행해야 더 빠르게 코드를 실행할 수 있다.
- 데이터 소스를 이용해서 주어진 조건과 일치하는 모든 데이터를 추출하고 결과에 어떤 연산을 적용하는 등 선언형으로 데이터를 처리하는 방식, 즉 간결하게 데이터 컬렉션을 다룬다

필드를 변화하고 반복자를 적용하는 기존의 객체지향, 명령형 언어로는 이러한 추세를 만족시키기 어렵다

#### 동작 파라미터화(람다와 메소드 참조)
재사용할 수 있는 filter 같은 메소드를 구현하려면 filter 메소드의 인수가 필터링 조건을 받도록 만들어야 한다 <br>
(필터링 조건을 메소드 내에서 클래스로 감싼 다음에 해당 클래스의 인스턴스를 전달하는 방법)<br>
하지만 보통 복잡한 코드를 구현해야 하며 따라서 유지보수 하는 것도 쉽지 않다 <br>
```java
apple -> apple.getWeight() > 150 
Apple::isHeavy
```

메소드로 전달되는 값은 Function<T,R> , Predicate<T>, BiFunction<T,U,R> 등의 형식을 가지며 메소드를 수신한 코드에서는 apply, test 등의 메소드로 코드를 실행할 수 있다 <br>

#### 스트림
자바의 컬렉션 클래스, 반복자 for-each 구문은 오랫동안 사용된 기능이다 <br>
자바 8의 설계자는 기존의 컬렉션에 람다를 활용한 filter, Map 등 메소드를 추가해서 데이터베이스 질의 같은 기능을 제공하는 쉬운 방법이 있다 <br>
컬렉션과 스트림은 비슷하면서도 다르다 <br>
컬렉션이면 3줄로 코드를 정리할 것을 스트림을 사용하면 파이프라인이라는 게으른 연산으로 구성해,한번의 탐색으로 모든 연산을 수행한다 <br>
큰 데이터 집합일수록 스트림의 데이터 처리 방식이 효율적이며, 또한 메모리 캐시 등의 관점에서도 커다란 데이터 집할일수록 탐색 횟수를 최소화 하는것이 중요하다 <br>

또한 멀티코어 CPU 를 활용해서 병렬로 요소룰 처리하는 기능도 매우 중요하다 <br>
스트림의 parallel 메소드는 스트림을 병렬로 처리하도록 지정하는 역할을 한다 <br>
상태 변화는 병렬성의 가장 큰 걸림돌이다. 따라서 함수형 개념은 map, filter 등의 연산을 활용하는 스트림의 병렬 처리의 핵심으로 자리 잡았다 <br>
(람다와 메소드 참조로 파라미터화 된 메소드, 외부 반복 대신 내부 반복을 지원하는 메소드)

#### CompletableFuture 클래스
자바 5부터 Future 인터페이스를 제공한다, Future 를 이용하면 여러 작업이 동시에 실행될 수 있도록 다른 스레드나 코어로 작업을 할당할 수 있다 <br>
즉 멀티코어를 잘 활용할 수 있게 된다. <br>
CompletableFuture 와 Future 의 관계는 스트림과 컬렉션의 관계와 같다 라는 이야기가 있다 <br>
- 스트림에서는 파이프라인 연산을 구성할 수 있으므로 map, filter 등으로 동작 파라미터화를 제공한다, 반복자를 사용할 때 생기는 불필요한 코드를 줄인다.

#### Optional 클래스
자바 8라이브러리는 T 형식의 값을 반환하거나, 값이 없음을 의미하는 Optional.empty 라는 정적 메소드를 반환하는 Optional<T> 를 제공한다 <br>
Optional<T> 는 에러가 잘 발생할 수 있는 계산을 수행하면서 값이 없을 때 에러를 발생시킬 수 있는 null 대신 정해진 데이터 형식을 제공한다 

위 클래스 를 이용하면 NPE 을 방지할 수 있다 <br>
없는 값의 형식을 다른 값으로 표현하는 기능이 도대체 프로그램 구현에 무슨 도움을 주는 걸까? <br>
Optional<T> 는 map, filter, ifPresent 를 제공한다 <br>

#### Flow API
호환성을 높일 수 있도록 라이브러리가 구현할 수 있는 4개의 인터페이스 Publisher, Subscriber, Subscription, Processor 를 포함한다.

#### 디폴트 메소드
```java
interface CalculateClass {
	void add(int a, int b);
	
	// 디폴트 메소드 -> 나중에 구현받아서 재구현할 수 있음.
	default void minus(int a, int b) {
		return a-b;
    }
}
```

### 자바 9 모듈 시스템
자바 9에서는 새로운 기능은 추가되지 않았지만 스트림의 기능을 강화했고, 새 모듈 시스템을 만들었다 <br>
자바 모듈 시스템이 제공하는 장점
- 안정적 설정
- 강한 캡슐화
- 보안성 개선
- 성능 개선
- 확장성

#### 자바 10 지역 변수형 추론
```java
Map<String,List<String>> myMap = new HashMap<String, List<String>>();
Map<String,List<String>> myMap = new HashMap<>();
var myMap = new HashMap<String, List<String>>();
```

위처럼 코드가 컴파일 될 때 생략된 형식을 추론해서 자동으로 타입을 넣어준다 -> 타입 추론 <br>

### 자바의 미래
자바에서는 제네릭의 서브 형식을 와일드카드로 지정할 수 있는 유연성을 허용한다.
```java
List<? extends Number> numbers = new ArrayList<Integer>(); // ? 에 Integer 가 들어가도 되고 상속받는 Number 형식이 들어가도 된다?
```

#### 패턴매칭

#### 기본형 특화와 제네릭
자바의 모든 기본형에는 대응하는 객체형이 존재한다. ex) int -> java.lang Integer <br>
이를 unboxed, boxed 타입이라고 부른다 <br>
반면 모든 제네릭과 마찬가지로 Function 도 객체형으로만 파라미터화 할 수 있다 <br>

자바 8에는 세 가지 종류의 값이 있다.
- 기본형의 값
- 객체(참조형)
- 함수(참조형)

변수형: 모든 것을 기본형이나 객체형으로 양분하지 않는다 <br>

#### 박싱, 제네릭, 값 형식: 상호 의존문제
함수형 프로그래밍에서는 식별자가 없는 불변값을 이용하므로 자바에서 값 형식을 지원한다면 좋을 것이다.<br>
자바에 값 형식이 지원된다면 기본형도 일종의 값 형식이 될 것이며 제네릭은 사라질 것이다. <br>

#### 더 빠르게 발전하는 자바
자바는 6개월 개발 주기를 갖는다.

### 기타 언어 업데이트 (APPENDIX A)





































