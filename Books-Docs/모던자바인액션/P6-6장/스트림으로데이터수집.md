# 스트림으로 데이터 수집

### 이장의 내용
- Collectors 클래스로 컬렉션을 만들고 사용하기 
- 하나의 값으로 데이터 스트림 리듀스 하기
- 특별한 리듀싱 요약 연산
- 데이터 그룹화와 분할
- 자신만의 커스텀 컬렉터 개발

전 챕터에서는 스트림을 이용해서 데이터베이스 연산을 수행할 수 있음을 배웠다 <br>
스트림의 연산은 filter 또는 map 같은 중간 연사과 count, findFirst, forEach, reduce 등의 최종 연산으로 구분할 수 있다 <br>
중간 연산은 한 스트림을 다른 스트림으로 변환하는 연산으로서, 여러 연산을 연결할 수 있다 <br>
중간 연산은 스트림 파이프라인을 구성하며, 스트림의 요소를 소비 하지 않는다 <br>
반면 최종 연산은 스트림의 요소를 소비해서 최종결과를 도출한다 <br>
ex) 스트림의 가장 큰 값 반환, 작은 값 반환 <br>
최종 연산은 스트림 파이프라인을 최적화하면서 계산 과정을 짧게 생략하기도 한다 <br>

지금부터 Collection, Collector, collect 를 헷갈리지 않도록 연습을 해보자 <br>

collect 와 Collector 로 구현할 수 있는 질의 예제이다
```java
// 통화별로 트랜잭션을 그룹화한 코드
Map<Currency, List<Transaction>> transactionsByCurrencies = 
    transactions.stream().collect(groupingBy(Transaction::getCurrency));
```

### 컬렉터란 무엇인가? 
함수형 프로그래밍에서는 '무엇'을 원하는지 직접 명시할 수 있어서 어떤 방법으로 이를 얻을지는 신경 쓸 필요가 없다 <br>
이전 예제에서 collect 메소드로 Collector 인터페이스 구현을 전달했다. <br>
각 요소를 List 로 만드는 -> toList 를 인터페이스의 구현으로 사용했다 <br>
다수준으로 그룹화를 수행할 때 명령형 프로그래밍과 함수형 프로그래밍의 차이점이 더욱 두드러진다 <br>
명령형 코드에서는 문제를 해결하는 과정에서 다중 루프와 조건문을 추가하며 가독성과 유지보수성이 크게 떨어진다 <br>

#### 고급 리듀싱 기능을 수행하는 Collector 
잘 설계된 함수형 API 의 또 다른 장점으로 높은 수준의 조합성과 재사용성을 꼽을 수 있다 <br>
collect 로 결과를 수집하는 과정을 간단하면서도 유연한 방식으로 정의를 할 수 있다는 점이 컬렉터의 최대 강점이다 <br>
스트림에 collect 를 호출하면 스트림의 요소에 리듀싱 연산이 수행된다. 내부적으로 리듀싱 연산이 일어나는 모습을 보여준다 <br>
보통 함수를 요소로 변환(toList 처럼 데이터 자체를 변환하는 것 보다는 데이터 저장 구조를 변환할 때가 많다) <br>
컬렉터를 적용하며 최종 결과를 저장하는 자료구조에 값을 누적한다 <br>
```java
List<Transaction> transactionList = transactionStream.collect(Collectors.toList());
```

#### 미리 정의된 컬렉터
미리 정의된 컬렉터 : groupingBy 같이 Collectors 클래스에서 제공하는 팩토리 메소드의 기능을 설명한다 <br>
Collectors 에서 제공하는 메소드의 기능은 크게 세 가지로 구분할 수 있습니다. <br>
1) 스트림 요소를 하나의 값으로 리듀스하고 요약
2) 요소 그룹화
3) 요소 분할

먼저 리듀싱과 요약 관련 기능을 수행하는 컬렉션부터 살펴보자 <br>

#### 리듀싱과 요약
Collector 로 Stream 의 모든 항목을 하나의 결과로 합칠 수 있다 <br>
좀 더 일반적으로 말해 컬렉터로 스트림의 모든 항목을 하나의 결과로 합칠 수 있다.
```java
// counting() 이라는 팩토리 메소드가 반환하는 컬렉터로 메뉴에서 요리 수를 계산한다.
long howManyDishes = menu.stream().collect(Collectors.counting());

// Refactor
long getHowManyDishes = menu.stream().count();
```

counting 컬렉터는 다른 컬렉터와 함께 사용할 때 유용하다 <br>

#### 스트림 값에서 최댓값과 최솟값 검색
Collectors.maxBy , Collectors.minBy 두 메소드를 이용해서 최댓값과 최솟값을 계산할 수 있다 <br>
```java
Comparator<Dish> dishCaloriesComparator = 
    Comparator.comparingInt(Dish::getCaloris);

Optional<Dish> mostCalorieDish = menu.stream()
    .collect(maxBy(dishCaloriesComparator));
```

Optional<Dish> 는 무슨 역할을 수행하는 것 일까? <br>
menu 가 비어있다면 그 어떤 요리도 반환되지 않는다.<br>
즉 있을수도 있고, 없을 수도 있는 컨테이너 Optional 을 제공한다. 그러면 Null 안정성이 더 높아진다 <br>

#### 요약 연산
Collectors 클래스는 Collectors.summingInt 라는 특별한 요약 팩토리 메소드를 제공한다 <br>
summingInt 는 객체를 int로 매핑하는 함수를 인수로 바든다 <br>
summingInt 의 인수로 전달된 함수는 객체를 int 로 매핑한 컬렉터를 반환한다. 그리고 summingInt 가 collect 메소드로 전달되면 요약 작업을 수행한다
```java
int totalCalories = menu.stream().collect(summingInt(Dish::getCalories));
```

합계 연산 말고 평균 연산 또한 가능하다
```java
double avgCalories = menu.stream().collect(averagingInt(Dish::getCalories));
```

다음은 하나의 요약 연산으로 메뉴에 있는 요소 수, 요리의 칼로리 합계, 평균, 최댓값, 최솟값 등을 계산하는 코드이다 <br>
```java
IntSummaryStatistics menuStatistics = menu.stream().collect(summarizingInt(Dish::getCalories));
```

위 코드 실행시 IntSummaryStatistics 클래스로 모든 정보가 수집된다. 

#### 문자열 연결
컬렉터에 joining 팩토리 메소드를 이용하면 스트림의 각 객체에 toString 메소드를 호출해서 추출한 모든 문자열을 하나의 문자열로 연결해서 반환한다 <br>
즉 다음은 메뉴의 모든 요리명을 연결하는 코드이다 <br>
```java
String shortMenu = menu.stream().map(Dish::getName).collect(joining());
```

joining 메소드는 내부적으로 StringBuilder 를 이용해서 문자열을 하나로 만든다. <br>
Dish 클래스가 요리명을 반환하는 toString 메소드를 포함하고 있다면 다음 코드에서 보여주는 것처럼 map 으로 각 요리의 이름을 추출하는 과정을 생략한다 
```java
String shortMenu = menu.stream().collect(joining());
```

하지만 이렇게 문자열을 다 합쳐버리면, 결과를 봐도 알아보기가 힘들다 그러므로 split 해줄수 있는 것을 추가한다.
```java
String shortMenu = menu.stream().map(Dish::getName).collect(joining(", "));
```

위 코드가 정석 코드라고 생각합니다.

#### 범용 리듀싱 요약 연산
지금까지 살펴본 모든 Collector 는 reducing 팩토리 메소드로도 정의할 수 있다, <br>
Collectors.reducing 으로도 구현이 가능하다 <br>




























































