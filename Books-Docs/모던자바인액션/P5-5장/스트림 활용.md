## 스트림 활용
### 필터링, 슬라이싱, 매칭
### 검색, 매칭, 리듀싱
### 특정 범위와 숫자와 같은 숫자 스트림 사용하기
### 다중 소스로부터 스트림 만들기
### 무한 스트림

4장에서는 스트림을 이용해서 외부 반복 -> 내부 반복으로 바꾸는 방법을 알아봤다.
```java
List<Dish> vegetarianDishes = new ArrayList<>();
for(Dish d: menu) {
	if(d.isVegetarian()) {
    vegetarianDishes.add(d);
    }
}

// 위 외부 반복 코드를 내부 반복코드로 만든다.

List<Dish> getVegetarianDishes = menu.stream()
    .filter(Dish::isvegetarian)
    .collect(toList());
```

데이터를 어떻게 처리할지는 스트림 API가 관리하므로 편리하게 데이터 관련 작업을 할 수 있다 <br>
따라서 스트림 API 내부적으로 다양한 최적화가 이루어질 수 있다 <br>
스트림 API는 내부 반복 뿐 아니라 코드를 병렬로 실행할지 여부도 결정할 수 있다 <br>
이러한 일은 순차적인 반복을 단일 스레드로 구현하는 외부 반복으로는 달성할 수 없다 <br>

### 필터링
스트림의 요소를 선택하는 방법, 즉 Predicate 필터링 방법과 고유 요소만 필터링하는 방법을 배운다

#### 프리디케이트로 필터링
스트림 인터페이스는 filter 메소드를 지원한다.<br>
filter 메소드는 Predicate(= return boolean) 을 인수로 받아서 Predicate 와 일치하는 모든 요소를 포함하는 스트림을 반환한다 <br>
예시를 봐보자
```java
List<Dish> vegetarianMenu = menu.stream()
    .filter(d -> dish.isvegetarian()) // 채식 요리인 것만 뽑아내는 람다식
    .collect(toList());
```

![img.png](img.png)

#### 고유 요소 필터링 (distinct)
스트림은 고유 요소로 이루어진 스트림을 반환하는 distinct 메소드도 지원한다 <br>
-> 고유 여부는 스트림에서 만든 객체의 hashcode, equals 로 결정된다 <br>
```java
List<Integer> numbers = Arrays.asList(1,2,3,41,5,16);
numbers.stream()
    .filter(i -> i%2 ==0)
    .distinct()
    .forEach(System.out::println);
```

![img_1.png](img_1.png)
위 순서대로 고유요소만 필터링이 작업이 된다. 

#### 스트림 슬라이싱 (takeWhile, dropWhile)
스트림의 요소를 선택하거나 스킵하는 다양한 방법이 있다.<br>
Predicate 를 이용하는 방법, 스트림의 처음 몇개의 요소를 무시하는 방법, 특정 크기로 스트림을 줄이는 방법 등 다양한 방법을 이용해 효율적으로 작업을 수행한다 <br>

TakeWhile 활용 <br>
```java
List<Dish> sliceMenu1 = specialMenu.stream()
    .takeWhile(dish -> dish.getCalories() < 320)
    .collect(toList());
```

위 takeWhile() 을 사용하면, 원하는 요소가 발견되었을 때 계속 스트림을 돌리는게 아닌, 반복 작업을 중단한다.

DropWhile 활용 <br>
dropWhile 은 Predicate 가 처음으로 거짓이 되는 지점까지 발견된 요소를 버린다 <br>
Predicate 가 거짓이 되면 그 지점에서 작업을 중단하고 남은 모든 요소를 반환한다 <br>
dropWhile 은 무한한 남은 요소를 가진 무한 스트림에서도 동작한다
```java
List<Dish> sliceMenu2 = specialMenu.stream()
    .dropWhile(dish -> dish.getCalories() < 320)
    .collect(toList());
```

#### 스트림 축소 (limit)
filter 와 조합해서 많이 사용하며, 원하는 개수까지만 요소를 뽑아낸다
```java
List<Dish> dishes = specialMenu.stream()
    .filter(dish -> dish.getCalories() > 300)
    .limit(3)
    .collect(toList());
```

![img_2.png](img_2.png)

정렬되지 않은 스트림에도 limit를 사용할 수 있다. 그러면 limit 의 결과도 정렬되지 않은 상태로 반환된다.<br>
그리고 limit 은 순서대로 처음 등장하는 것부터 n 개 까지만 출력하게끔 한다.

#### 요소 건너뛰기(skip)
스트림은 <b style="color:red">처음 n개 요소를 제외 </b> 한 스트림을 반환하는 skip() 메소드를 지원한다 <br>
limit(n) 과 skip(n) 은 상호보완적인 연산을 수행한다. 아례 예시를 보자
```java
List<Dish> dishes = menu.stream()
    .filter(d -> d.getCalories() > 300)
    .skip(2)
    .collect(toList());
```

![img3.png](img3.png)

위 경우는 앞에 2가지 값을 제외하고 그 이후부터 요소를 뽑아낸다.

### 매핑
특정 객체에서 특정 데이터를 선택하는 작업은 데이터 처리과정에서 자주 수행되는 연산이다 <br>
ex) sql 테이블에서 특정 열만 선택한다. 이 과정을 스트림에서 map, flatMap 메소드를 사용해서 할 수 있다.

#### 스트림의 각 요소에 함수 적용하기
스트림은 함수를 인수로 받는 map 메소드를 지원한다. 인수로 제공된 함수는 각 요소에 적용되며 함수를 적용한 결과가 새로운 요소로 매핑된다 <br>
위 과정을 '변환' -> '매핑' 이라고 한다. 예시를 보자
```java
List<String> dishNames = menu.stream()
    .map(Dish::getName)
    .collect(toList());
```

getName 을 통해 Dish 에 있는 이름(문자열)을 반환하여 스트림에 저장한다 <br>
다른 예시를 봐보자, List 의 단어 길이를 저장하는 예제이다.
```java
List<String> words = Arrays.asList("Modern","Java","In","Action");
List<Integer> wordLengths = words.stream()
    .map(String::length)
    .collect(toList());
```

다른 예제를 보자, 요리명만 추출한 후 길이를 저장하는 예제이다
```java
List<Integer> cookName = menu.stream()
    .map(Dish::getName)
    .map(String::length)
    .collect(toList());
```

#### 스트림 평면화

List 에 있는 단어를 문자로 매핑 후 한 단어씩 저장되게 만들어보자
```java
List<String> list = word.stream()
    .map(word -> word.split(""))
    .distinct()
    .collect(toList());
```

위 코드에서 map 으로 전달한 람다는 각 단어의 String[] 을 반환한다 <br>
따라서 map 메소드가 반환한 스트림 형식은 Stream<String[]> 이다 <br>
우리가 원하는 것은 문자열의 스트림을 표현할 Stream<String> 이다 <br>
![img_4.png](img_4.png)

위 문제를 해결하기 위해 flatMap 이라는 메소드를 이용해서 문제를 해결한다 <br>

#### map 과 Arrays.stream 활용
우선 배열 스트림 대신 문자열 스트림이 필요하다 <br>
```java
String[] arrayOfWords = {"GoodBye","World"};
Stream<String> streamOfWords = Arrays.stream(arrayOfWords);
```

위 코드를 Arrays.stream() 을 적용해보자
```java
words.stream()
    .map(word -> word.spilt(""))
    .map(Arrays::stream)
    .distinct()
    .collect(toList());
```

아직 문제가 해결되지 않았다. 

#### flatMap 사용
flatMap 을 사용하면 문제를 해결할 수 있었다
```java
List<String> uniqueChars = words.stream()
    .map(word -> word.spilt("")) // 각 단어를 개별 문자를 포함하는 배열로 변환
    .flatMap(Arrays::stream) // 생성된 스트림을 하나의 스트림으로 평면화
    .distinct()
    .collect(toList());
```

flatMap 은 각 배열을 스트림이 아닌 스트림의 콘텐츠로 매핑한다. 즉, map(Arrays::stream) 과 달리 flatMap 은 하나의 평면화된 스트림을 반환한다 <br>
요약하면 flatMap 메소드는 스트림의 각 값을 다른 스트림으로 만든 다음에 모든 스트림을 하나의 스트림으로 연결하는 기능을 수행한다.
![img_5.png](img_5.png)


### 검색과 매칭
여기부터 읽기



























































































