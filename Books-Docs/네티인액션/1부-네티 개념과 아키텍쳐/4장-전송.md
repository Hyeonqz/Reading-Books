## 4장 - 전송
- OIO: 블로킹 전송
- NIO: 비동기 전송
- 로컬 전송: JVM 내에서의 비동기 통신
- 임베디드 전송: ChannelHandler 테스트

네트워크를 통해 전송되는 데이터는 모두 동일한 형식(byte)이다 <br>
바이트가 전송되는 구체적인 방법은 데이터 전송의 기본 메커니즘을 추상화하도록 도와주는 개념인 네트워크 전송에 의해 좌우된다 <br>
블로킹 전송을 논블로킹 전송으로 전화하려고 했다면 두 네트워크 API 의 차이점 때문에 쉽지 않다는 것도 알 수 있을 것이다 <br>

반면 네티는 모든 전송 구현에 공통 API 를 기반 레이어로 활용하므로 JDK 를 직접 이용할 때 보다 이러한 변환이 훨씬 간단하다 <br>

코드가 구현 세부 사항으로 오염될 우려가 적고, 전체 코드 기반을 광범위하게 리팩토링 할 필요가 없다, 즉 생산적인 일을 하는데 시간을 투자할 수 있다 <br>

### 사례 연구: 전송 마이그레이션
연결을 수락한 다음 클라이언트로 "Hi" 라는 메시지를 전송하고 연결을 닫는 간단한 애플리케이션을 작성하면서 전송에 대해 알아보자 <br>
먼저 네티 없이 JDK API(java.net.* , java.io.*) 만 이용하는 OIO, NIO 버전의 애플리케이션 코드를 보자.
```java
public class PlainOioServer {
	public void serve(int port) throws IOException {
		final ServerSocket serverSocket = new ServerSocket(port);
		try{
			for(;;) {
				final Socket clientSocket = serverSocket.accept();
				System.out.println("Accepted connection from " + clientSocket.getRemoteSocketAddress() + "Client Socket : " + clientSocket);
				
				new Thread(new Runnable() {

					@Override
					public void run () {
						OutputStream out;
						try {
							out = clientSocket.getOutputStream();
							out.write("Hi\r\n".getBytes(Charset.forName("UTF-8")));
							out.flush();
							clientSocket.close();
						} catch (IOException e) {
							throw new RuntimeException(e);
						} finally {
							try {
								clientSocket.close();
							} catch (IOException e) {
								throw new RuntimeException(e);
							}
						}
					}
				}).start();
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
```

위 코드도 일정 수준의 동시 클라이언트를 지원할 수 있지만 애플리케이션이 인기를 얻어 동시 접속자가 수만 명까지 증가하면 제대로 작동하지 않을 수 있다 <br>
블로킹 방식보다 확장성이 좋은 비동기 네트워킹으로 전환하려고 해보지만 비동기 API 가 완전히 다르다는 것을 알고는 애플리케이션을 다시 작성하게 된다<br>

아래는 java.nio 버전이다.
```java
public class PlainNioServer {
	public void server(int port) throws Exception {
		ServerSocketChannel serverSocketChannel= ServerSocketChannel.open();
		serverSocketChannel.configureBlocking(false);
		ServerSocket ssocket = serverSocketChannel.socket();
		InetSocketAddress address = new InetSocketAddress(port);
		
		ssocket.bind(address);

		Selector selector = Selector.open();
		serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
		
		final ByteBuffer msg = ByteBuffer.wrap("Hi\r\n".getBytes());
		
		for(;;) {
			try {
				selector.select();
			} catch (IOException e) {
				e.printStackTrace();
				break;
			}
		}

		Set<SelectionKey> readyKeys = selector.selectedKeys();
		Iterator<SelectionKey> iterator = readyKeys.iterator();
		while(iterator.hasNext()) {
			SelectionKey key = iterator.next();
			iterator.remove();
			try {
				if(key.isAcceptable()) {
					ServerSocketChannel server = (ServerSocketChannel) key.channel();
					SocketChannel client = server.accept();
					client.configureBlocking(false);
					client.register(selector, SelectionKey.OP_WRITE, msg.duplicate());
					System.out.println("Accepted connection from " + client);
				}
				if(key.isWritable()) {
					SocketChannel client = (SocketChannel) key.channel();
					ByteBuffer buffer = (ByteBuffer) key.attachment();
					while(buffer.hasRemaining()) {
						if(client.write(buffer) == 0) {
							break;
						}
					}
					client.close();
				}
			} catch (IOException e) {
				key.channel();
				try {
					key.channel().close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
	}
}

```

위 예제는 이전 예제와 사실상 같은 일을 하지만 코드는 크게 달라진다. 일단 코드가 훨씬 길어지고 해석하기 어려워졌다 <br>
보면 알다시피 블로킹 -> 논블로킹 으로 변환하는데 많은 코드 변환이 필요하다<br>

#### 네티와 함께 OIO 와 NIO 사용

**블로킹 네티 버젼**
```java
public class NettyOioServer {
	public void server(int port) throws InterruptedException {
		final ByteBuf byteBuf = Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("Hi\r\n", Charset.forName("UTF-8")));
		EventLoopGroup group = new OioEventLoopGroup();
		try {
			ServerBootstrap bootstrap = new ServerBootstrap();
			bootstrap.group(group)
				.channel(OioServerSocketChannel.class)
				.localAddress(new InetSocketAddress(port))
				.childHandler(new ChannelInitializer<SocketChannel>() {

					@Override
					protected void initChannel (SocketChannel ch) throws Exception {
						ch.pipeline().addLast(
							new ChannelInboundHandlerAdapter() {

								@Override
								public void channelActive (ChannelHandlerContext ctx) throws Exception {
									ctx.writeAndFlush(byteBuf.duplicate()).addListener(ChannelFutureListener.CLOSE);
								}
							}
						);
					}
				});
			ChannelFuture future = bootstrap.bind().sync();
			future.channel().closeFuture().sync();
		} finally {
			group.shutdownGracefully().sync();
		}
	}
}

```

**논블로킹 네티버전**
```java
public class NettyNioServer {
	public void server(int port) throws Exception {
		final ByteBuf byteBuf = Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("Hi\r\n", Charset.forName("UTF-8")));
		EventLoopGroup group = new NioEventLoopGroup();
		try {
			ServerBootstrap bootstrap = new ServerBootstrap();
			bootstrap.group(group)
				.channel(NioSctpServerChannel.class)
				.localAddress(new InetSocketAddress(port))
				.childHandler(new ChannelInitializer<SocketChannel>() {

					@Override
					protected void initChannel (SocketChannel ch) throws Exception {
						ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {
							@Override
							public void channelActive(ChannelHandlerContext ctx) throws Exception {
								ctx.writeAndFlush(byteBuf.duplicate())
									.addListener(ChannelFutureListener.CLOSE);
							}
						});
					}
				});
			ChannelFuture future = bootstrap.bind().sync();
			future.channel().closeFuture().sync();
		} finally {
			group.shutdownGracefully();
		}
	}
}

```

어떤 전송 방식을 선택하든 네티는 모든 전송의 구현에 동일한 API 를 노출하므로 전송을 변경해도 코드는 거의 영향을 받지 않는다 <br>
즉 모든 구현이 Channel, ChannelPipeline, ChannelHandler 인터페이스를 기준으로 정의된다.<br>

### 전송 API
Channel 인터페이스는 모든 입출력 작업에 이용되므로 전송 API 핵심이라고 할 수 있다








































